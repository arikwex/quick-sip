/**
 * @class Quick-Sip
 * @constructor
 * @param gulp {Gulp} reference to the gulp object.
 * @param options {Object} configuration options for the build task.
 *  @param options.taskPrefix {String} prefix to use for all task names.
 *  @param options.transformStack {String[]} array of transforms to apply during the browserify process
 *  @param options.rootSrc {String} path to the root src directory.
 *  @param options.rootJS {String} path (relative or absolute) to the main .js file to start bundling.
 *  @param options.rootScss {String} path to the sass files to compile.
 *  @param options.scssIncludes {String[]} paths to additional includes for building sass.
 *  @param options.dist {String} path (relative or absolute) to where you want the distribution.
 *  @param options.browserifyResult {String} the name of the app file that is generated by browserify.
 *  @param options.skipBrowserify {Boolean} whether to skip browserify.
 *  @param options.skipScss {Boolean} whether to skip compiling the styles.
 *  @param options.skipCopyResources {Boolean} whether to skip the copy resources step.
 *  @param options.failOnError {Boolean} whether failures during the browserify process should error the build or continue.
 *  @param options.debug {Boolean} whether to run browserify in debug mode.
 */
module.exports = function(gulp, options) {
  options = options || {};
  var browserifyBundler,
      taskPrefix = options.taskPrefix || '',
      failOnError = options.failOnError || false,
      transformStack = options.transformStack || [],
      nonResources = options.nonResources || 'js|css|scss',
      fs = require('fs'),
      gulpLoadPlugins = require('gulp-load-plugins'),
      $ = gulpLoadPlugins({}),
      del = require('del'),
      log = require('color-log'),
      pathLib = require('path'),
      source = require('vinyl-source-stream'),
      buffer = require('vinyl-buffer'),
      watchify = require('watchify'),
      browserify = require('browserify'),
      runSequence = require('run-sequence').use(gulp),
      paths = {
        app: options.rootSrc || 'app',
        scripts: 'scripts',
        styles: 'styles',
        templates: 'scripts/**/templates',
        dist: options.dist || 'dist',
        rootJs: options.rootJS || 'main',
        rootScss: options.rootScss || 'app'
      },
      buildTasks = [];

  if (!options.skipCopyResources) {
    buildTasks.push(taskPrefix + 'copy-resources');
  }

  if (!options.skipScss) {
    buildTasks.push(taskPrefix + 'build-styles');
  }

  if (!options.skipBrowserify) {
    buildTasks.push(taskPrefix + 'build-app');
  }

  function defaultPath(path, defaultPath) {
    if (typeof path === 'string') {
      if (path[0] === '.' || path[0] === '/') {
        return path;
      }
      return defaultPath + path;
    }
    return path;
  };

  /* Current date-time printer */
  function currentDateTime() {
    var date = new Date(),
        datetime = '';
    datetime += date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds() + ' ';
    datetime += (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
    return datetime;
  };

  /* Browserify bundler */
  watchify.args.debug = ($.util.env.type !== 'production' || options.debug);
  function configureBrowserify(browserifyBundler) {
    browserifyBundler.add(defaultPath(paths.rootJs, './' + paths.app + '/' + paths.scripts + '/'));
    transformStack.forEach(function(transform) {
      if (transform.name) {
        browserifyBundler.transform(transform.name, transform.options);
      } else {
        browserifyBundler.transform(transform);
      }
    })
  };

  /* Clean the paths.dist directory */
  gulp.task(taskPrefix + 'clean', function(callback) {
    log.mark('[CLEAN] deleting ' + paths.dist);
    del(paths.dist, callback);
  });

  /* Copy all resources to dist */
  function copyResources() {
    var bytes = 0,
        startTime = +new Date();
    return gulp.src([
        paths.app + '/**/*.*',
        '!' + paths.app + '/**/*.+(' + nonResources + ')',
      ])
      .pipe($.tap(function(file, callback) {
        bytes += fs.statSync(file.path).size;
        return callback;
      }))
      .pipe(gulp.dest(paths.dist))
      .pipe($.concat('tmp'))
      .pipe($.tap(function() {
        var endTime = +new Date();
        log.mark('[RESOURCES] ' + bytes + ' bytes written (' + (endTime - startTime)/1000.0 + ' seconds)');
      }));
  };
  gulp.task(taskPrefix + 'copy-resources', copyResources);

  /* Handle single resource events for dist */
  function copyResource(evt, callback) {
    var status = evt.type,
        path = evt.path,
        relPath = pathLib.relative('./app', evt.path),
        srcPath = path,
        destPath = './' + paths.dist;

    if (status === 'changed') {
      log.mark('[MODIFY] --> ' + relPath);
      return gulp.src(srcPath)
        .pipe($.concat(relPath))
        .pipe(gulp.dest(destPath));
    } else if (status === 'added') {
      log.mark('[ADDED] --> ' + relPath);
      return gulp.src(srcPath)
        .pipe($.concat(relPath))
        .pipe(gulp.dest(destPath));
    } else if (status === 'renamed') {
      log.mark('[RENAMED] --> ' + relPath);
      return gulp.src(srcPath)
        .pipe($.concat(relPath))
        .pipe(gulp.dest(destPath));
    } else if (status === 'deleted') {
      log.mark('[DELETED] --> ' + relPath);
      del(destPath + '/' + relPath, callback);
    }
  };

  /* Build all styles */
  function buildStyles() {
    return gulp.src([options.rootSrc || (paths.app + '/**/*.scss')])
      .pipe($.sass({
        file: defaultPath(paths.rootScss, paths.app),
        includePaths: options.scssIncludes || [],
        onSuccess: function(err) {
          log.mark('[SASS] ' + err.css.length + ' bytes written (' + (err.stats.duration / 1000.0) + ' seconds)');
        },
        onError: function(err) {
          log.error('[SASS] @ ' + currentDateTime());
          log.warn('File: [line:' + err.line + ', col:' + err.column + '] ' + err.file);
          log.warn('Message: ' + err.message);
        }
      }))
      .pipe($.autoprefixer())
      .pipe(gulp.dest(paths.dist))
  };
  gulp.task(taskPrefix + 'build-styles', buildStyles);

  /* Reduce all javascript to app.js */
  function buildApp() {
    return browserifyBundler.bundle()
      .on('error', function(err) {
        delete err.stream;
        log.error('[BROWSERIFY] @ ' + currentDateTime());
        log.warn(err.toString());
        if (!browserifyBundler.continueOnError && failOnError) {
          throw err;
        }
        return true;
      })
      .pipe(source(options.browserifyResult || 'app.js'))
      .pipe(buffer())
      .pipe($.util.env.type !== 'production' ? $.sourcemaps.init({loadMaps: true}) : $.util.noop())
      .pipe($.util.env.type === 'production' ? $.uglify() : $.util.noop())
      .pipe($.util.env.type !== 'production' ? $.sourcemaps.write('./') : $.util.noop())
      .pipe(gulp.dest(options.dist || (paths.dist + '/' + paths.scripts)));
  };
  gulp.task(taskPrefix + 'build-app', buildApp);

  /* Full build */
  gulp.task(taskPrefix + 'build', function(callback) {
    browserifyBundler = browserify(watchify.args);
    configureBrowserify(browserifyBundler);
    runSequence(taskPrefix + 'clean', buildTasks,
      function() {
        log.mark('[BROWSERIFY] complete!');
        callback();
      });
  });

  /* Watch build */
  gulp.task('watch', function() {
    browserifyBundler = watchify(browserify(watchify.args));
    browserifyBundler.continueOnError = true;
    configureBrowserify(browserifyBundler);
    gulp.watch(paths.app + '/' + paths.styles + '/**/*.scss', buildStyles);
    gulp.watch([
      paths.app + '/**/*.*',
      '!' + paths.app + '/**/*.+(' + nonResources +')',
    ], copyResource);
    browserifyBundler.on('update', buildApp);
    browserifyBundler.on('log', function(data) {
      log.mark('[BROWSERIFY] ' + data.toString());
    });
    runSequence(taskPrefix + 'clean', buildTasks);
  });

  /* Returns public configuration API */
  return {
    transform: function(fn) {
      transformStack.push(fn);
    },

    nonResources: function(nrsc) {
      nonResources = nrsc;
    },

    setRootJS: function(rootJs) {
      paths.rootJs = rootJs;
    },

    setRootSCSS: function(rootScss) {
      paths.rootScss = rootScss;
    },

    setDist: function(dist) {
      paths.dist = dist;
    },

    setNoScss: function() {
      var buildStylesIndex = buildTasks.indexOf(taskPrefix + 'build-styles');
      if (buildStylesIndex > -1) {
        buildTasks.splice(buildStylesIndex, 1);
      }
    },

    setNoCopyResources: function() {
      var copyResourcesIndex = buildTasks.indexOf(taskPrefix + 'copy-resources');
      if (copyResourcesIndex > -1) {
        buildTasks.splice(copyResourcesIndex, 1);
      }
    },

    setFailOnError: function() {
      failOnError = true;
    }
  };
};