/**
 * @class Quick-Sip
 * @constructor
 * @param gulp {Gulp} reference to the gulp object.
 * @param options {Object} configuration options for the build task.
 *  @param options.taskPrefix {String} prefix to use for all task names.
 *  @param options.transformStack {String[]} array of transforms to apply during the browserify process
 *  @param options.rootSrc {String} path to the root src directory.
 *  @param options.rootJS {String} path (relative or absolute) to the main .js file to start bundling.
 *  @param options.rootScss {String} path to the sass files to compile.
 *  @param options.scssIncludes {String[]} paths to additional includes for building sass.
 *  @param options.dist {String} path (relative or absolute) to where you want the distribution.
 *  @param options.browserifyResult {String} the name of the app file that is generated by browserify.
 *  @param options.skipBrowserify {Boolean} whether to skip browserify.
 *  @param options.skipScss {Boolean} whether to skip compiling the styles.
 *  @param options.skipCopyResources {Boolean} whether to skip the copy resources step.
 *  @param options.failOnError {Boolean} whether failures during the browserify process should error the build or continue.
 *  @param options.debug {Boolean} whether to run browserify in debug mode.
 */
module.exports = function(gulp, options) {
  var _ = require('lodash'),
      fs = require('fs'),
      gulpLoadPlugins = require('gulp-load-plugins'),
      $ = gulpLoadPlugins({}),
      del = require('del'),
      log = require('color-log'),
      pathLib = require('path'),
      source = require('vinyl-source-stream'),
      buffer = require('vinyl-buffer'),
      watchify = require('watchify'),
      browserify = require('browserify'),
      runSequence = require('run-sequence').use(gulp);

  var browserifyBundler,
      buildTasks = [];

  // Properties used in the defaults below.
  options = _.merge({
    src: 'app',
    dist: 'dist'
  }, options);

  // Default options
  options = _.merge({
    taskPrefix: '',
    styles: 'styles',
    clean: {
      skip: false,
      dist: options.dist
    },
    browserify: {
      skip: false,
      transformStack: [],
      root: './' + options.src + '/scripts/main',
      out: 'app.js',
      failOnError: false,
      debug: $.util.env.type !== 'production',
      dist: options.dist + '/scripts'
    },
    sass: {
      skip: false,
      src: options.src + '/**/*.scss',
      root: options.src + '/app',
      includes: [],
      dist: options.dist
    },
    copy: {
      skip: false,
      nonResources: 'js|css|scss',
      src: options.src,
      dist: options.dist
    }
  }, options);

  // Setup build tasks.
  if (!options.copy.skip) {
    buildTasks.push(options.taskPrefix + 'copy-resources');
  }

  if (!options.sass.skip) {
    buildTasks.push(options.taskPrefix + 'build-styles');
  }

  if (!options.browserify.skip) {
    buildTasks.push(options.taskPrefix + 'build-app');
  }

  /* Current date-time printer */
  function currentDateTime() {
    var date = new Date(),
        datetime = '';
    datetime += date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds() + ' ';
    datetime += (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
    return datetime;
  };

  /* Browserify bundler */
  watchify.args.debug = ($.util.env.type !== 'production' || options.debug);
  function configureBrowserify(browserifyBundler) {
    browserifyBundler.add(options.browserify.root);
    options.browserify.transformStack.forEach(function(transform) {
      if (transform.name) {
        browserifyBundler.transform(transform.name, transform.options);
      } else {
        browserifyBundler.transform(transform);
      }
    })
  };

  /* Clean the options.dist directory */
  gulp.task(options.taskPrefix + 'clean', function(callback) {
    if (!options.clean.skip) {
      log.mark('[CLEAN] deleting ' + options.clean.dist);
      del(options.clean.dist, callback);
    } else {
      callback();
    }
  });

  /* Copy all resources to dist */
  function copyResources() {
    var bytes = 0,
        startTime = +new Date();
    return gulp.src([
        options.copy.src + '/**/*.*',
        '!' + options.copy.src + '/**/*.+(' + options.browserify.nonResources + ')',
      ])
      .pipe($.tap(function(file, callback) {
        bytes += fs.statSync(file.path).size;
        return callback;
      }))
      .pipe(gulp.dest(options.copy.dist))
      .pipe($.concat('tmp'))
      .pipe($.tap(function() {
        var endTime = +new Date();
        log.mark('[RESOURCES] ' + bytes + ' bytes written (' + (endTime - startTime)/1000.0 + ' seconds)');
      }));
  };
  gulp.task(options.taskPrefix + 'copy-resources', copyResources);

  /* Handle single resource events for dist */
  function copyResource(evt, callback) {
    var status = evt.type,
        path = evt.path,
        relPath = pathLib.relative('./' + options.copy.src, evt.path),
        srcPath = path,
        destPath = './' + options.copy.dist;

    if (status === 'changed') {
      log.mark('[MODIFY] --> ' + relPath);
      return gulp.src(srcPath)
        .pipe($.concat(relPath))
        .pipe(gulp.dest(destPath));
    } else if (status === 'added') {
      log.mark('[ADDED] --> ' + relPath);
      return gulp.src(srcPath)
        .pipe($.concat(relPath))
        .pipe(gulp.dest(destPath));
    } else if (status === 'renamed') {
      log.mark('[RENAMED] --> ' + relPath);
      return gulp.src(srcPath)
        .pipe($.concat(relPath))
        .pipe(gulp.dest(destPath));
    } else if (status === 'deleted') {
      log.mark('[DELETED] --> ' + relPath);
      del(destPath + '/' + relPath, callback);
    }
  };

  /* Build all styles */
  function buildStyles() {
    return gulp.src(options.sass.src)
      .pipe($.sass({
        file: options.sass.root,
        includePaths: options.sass.includes,
        onSuccess: function(err) {
          log.mark('[SASS] ' + err.css.length + ' bytes written (' + (err.stats.duration / 1000.0) + ' seconds)');
        },
        onError: function(err) {
          log.error('[SASS] @ ' + currentDateTime());
          log.warn('File: [line:' + err.line + ', col:' + err.column + '] ' + err.file);
          log.warn('Message: ' + err.message);
        }
      }))
      .pipe($.autoprefixer())
      .pipe(gulp.dest(options.sass.dist))
  };
  gulp.task(options.taskPrefix + 'build-styles', buildStyles);

  /* Reduce all javascript to app.js */
  function buildApp() {
    return browserifyBundler.bundle()
      .on('error', function(err) {
        delete err.stream;
        log.error('[BROWSERIFY] @ ' + currentDateTime());
        log.warn(err.toString());
        if (!browserifyBundler.continueOnError && options.browserify.failOnError) {
          throw err;
        }
        return true;
      })
      .pipe(source(options.browserify.out))
      .pipe(buffer())
      .pipe($.util.env.type !== 'production' ? $.sourcemaps.init({loadMaps: true}) : $.util.noop())
      .pipe($.util.env.type === 'production' ? $.uglify() : $.util.noop())
      .pipe($.util.env.type !== 'production' ? $.sourcemaps.write('./') : $.util.noop())
      .pipe(gulp.dest(options.browserify.dist));
  };
  gulp.task(options.taskPrefix + 'build-app', buildApp);

  /* Full build */
  gulp.task(options.taskPrefix + 'build', function(callback) {
    browserifyBundler = browserify(watchify.args);
    configureBrowserify(browserifyBundler);
    runSequence(options.taskPrefix + 'clean', buildTasks,
      function() {
        log.mark('[BROWSERIFY] complete!');
        callback();
      });
  });

  /* Watch build */
  gulp.task('watch', function() {
    browserifyBundler = watchify(browserify(watchify.args));
    browserifyBundler.continueOnError = true;
    configureBrowserify(browserifyBundler);
    gulp.watch(options.sass.src, buildStyles);
    gulp.watch([
      options.copy.src + '/**/*.*',
      '!' + options.copy.src + '/**/*.+(' + options.copy.nonResources +')',
    ], copyResource);
    browserifyBundler.on('update', buildApp);
    browserifyBundler.on('log', function(data) {
      log.mark('[BROWSERIFY] ' + data.toString());
    });
    runSequence(options.taskPrefix + 'clean', buildTasks);
  });

  /* Returns public configuration API */
  return {
    transform: function(fn) {
      options.browserify.transformStack.push(fn);
    },

    nonResources: function(nrsc) {
      options.browserify.nonResources = nrsc;
    },

    options: function(newOptions) {
      _.merge(options, newOptions);
    }
  };
};